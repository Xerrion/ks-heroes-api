#!/usr/bin/env python3
"""
Comprehensive Hero API Seed Generator
Generates idempotent SQL seed file from JSON data sources.

Optimized for battle simulator data consumption.

Supports:
- heroes.json
- heroes_conquest_base.json
- heroes_expedition_base.json
- hero_skills.json
- exclusive_gear.json

Output: supabase/seed.sql
"""

from __future__ import annotations

import json
import re
from decimal import Decimal
from pathlib import Path
from typing import Any

from rich.console import Console
from rich.panel import Panel

# Configuration
DATA_DIR = Path("./data")
OUT_SQL = Path("supabase/seed.sql")

# Rich console for beautiful output
console = Console()

# Global state
_slug_pattern = re.compile(r"[^a-z0-9]+")
_warned_skips: set[tuple[str, str]] = set()


def sql_q(value: Any) -> str:
    """Quote value for SQL, handling None, booleans, numbers, and strings."""
    if value is None:
        return "NULL"
    if isinstance(value, bool):
        return "TRUE" if value else "FALSE"
    if isinstance(value, (int, float, Decimal)):
        return str(value)
    return "'" + str(value).replace("'", "''") + "'"


def as_jsonb(obj: Any) -> str:
    """Convert Python object to JSONB literal."""
    if obj is None:
        return "NULL"
    return sql_q(json.dumps(obj, ensure_ascii=False, separators=(",", ":")))


def slugify(value: str) -> str:
    """Create URL-safe slug from text."""
    slug = _slug_pattern.sub("-", value.strip().lower())
    return slug.strip("-")


def load_json(path: Path) -> Any:
    """Load and parse JSON file."""
    return json.loads(path.read_text(encoding="utf-8"))


def warn_skipped(context: str, hero_slug: str) -> None:
    """Warn once about skipped entries."""
    key = (context, hero_slug)
    if key in _warned_skips:
        return
    _warned_skips.add(key)
    console.print(f"[yellow]‚ö†Ô∏è  Skipping {context} for hero '{hero_slug}'[/yellow]")


def ensure_hero_known(
    hero_slug: str | None, known_heroes: set[str] | None, context: str
) -> bool:
    """Verify hero exists before inserting related data."""
    if not hero_slug:
        return False
    if known_heroes and hero_slug not in known_heroes:
        warn_skipped(context, hero_slug)
        return False
    return True


def sorted_level_items(levels: Any) -> list[tuple[int, Any]]:
    """Sort level dictionary items by level number."""
    items: list[tuple[int, Any]] = []
    if not isinstance(levels, dict):
        return items
    for key, value in levels.items():
        try:
            lvl = int(str(key))
        except (TypeError, ValueError):
            continue
        items.append((lvl, value))
    items.sort(key=lambda kv: kv[0])
    return items


def emit_header() -> str:
    """Generate SQL file header."""
    return """-- seed.sql generated by generate_seed_sql.py
-- Comprehensive hero data for battle simulator API
-- Generated: 2025-11-13

BEGIN;

SET LOCAL client_min_messages = WARNING;

-- Create temp flag to disable sequential validation during bulk seeding
CREATE TEMP TABLE disable_level_validation();

"""


def emit_footer() -> str:
    """Generate SQL file footer."""
    return """
-- Drop temp flag so subsequent operations re-enable validation
DROP TABLE IF EXISTS disable_level_validation;

COMMIT;
"""


def normalize_skill_type(s: str | None) -> str:
    """Normalize skill type to valid enum value."""
    if not s:
        return "Passive"
    s = s.strip().title()
    if s not in {"Active", "Passive", "Rage", "Talent", "Expedition"}:
        return "Passive"
    return s


def extract_upgrade_value(payload: Any) -> Any:
    """Extract numeric upgrade value from skill effect payload."""
    if not isinstance(payload, dict):
        return None

    for key in ("value_pct", "value", "value_flat", "value_amount"):
        val = payload.get(key)
        if isinstance(val, (int, float, Decimal)):
            return val
        if isinstance(val, str):
            try:
                return float(val.strip().rstrip("%"))
            except ValueError:
                pass

    return None


def build_heroes_sql(p: Path) -> tuple[str, set[str]]:
    """Build SQL for heroes table."""
    data = load_json(p)
    out = [
        "-- ============================================================================"
    ]
    out.append("-- HEROES")
    out.append(
        "-- ============================================================================\n"
    )

    hero_slugs: set[str] = set()

    for h in data:
        name = h.get("name")
        if not name:
            continue

        hero_slug = h.get("id") or slugify(name)
        hero_slugs.add(hero_slug)

        rarity = h.get("rarity")
        generation = h.get("generation")
        klass = h.get("class")
        image_path = h.get("image_path")
        sources = h.get("sources")

        out.append(
            "INSERT INTO heroes (hero_id_slug, name, rarity, generation, class, image_path, sources)\n"
            f"VALUES ({sql_q(hero_slug)}, {sql_q(name)}, {sql_q(rarity)}, {sql_q(generation)}, "
            f"{sql_q(klass)}, {sql_q(image_path)}, {as_jsonb(sources)})\n"
            "ON CONFLICT (hero_id_slug) DO UPDATE SET\n"
            "  name = EXCLUDED.name,\n"
            "  rarity = EXCLUDED.rarity,\n"
            "  generation = EXCLUDED.generation,\n"
            "  class = EXCLUDED.class,\n"
            "  image_path = COALESCE(EXCLUDED.image_path, heroes.image_path),\n"
            "  sources = COALESCE(EXCLUDED.sources, heroes.sources);\n"
        )

    console.print(f"[green]‚úì[/green] Processed {len(hero_slugs)} heroes")
    return "\n".join(out) + "\n\n", hero_slugs


def build_conquest_base_sql(p: Path, known_heroes: set[str] | None) -> str:
    """Build SQL for hero_conquest_stats table."""
    data = load_json(p)
    out = [
        "-- ============================================================================"
    ]
    out.append("-- CONQUEST STATS")
    out.append(
        "-- ============================================================================\n"
    )

    count = 0
    for row in data:
        hero_slug = row.get("hero_id")
        if not ensure_hero_known(hero_slug, known_heroes, "conquest_stats"):
            continue

        attack = row.get("attack", 0)
        defense = row.get("defense", 0)
        health = row.get("health", 0)

        out.append(
            "INSERT INTO hero_conquest_stats (hero_id, attack, defense, health)\n"
            f"VALUES ((SELECT id FROM heroes WHERE hero_id_slug = {sql_q(hero_slug)}), "
            f"{sql_q(attack)}, {sql_q(defense)}, {sql_q(health)})\n"
            "ON CONFLICT (hero_id) DO UPDATE SET\n"
            "  attack = EXCLUDED.attack,\n"
            "  defense = EXCLUDED.defense,\n"
            "  health = EXCLUDED.health;\n"
        )
        count += 1

    console.print(f"[green]‚úì[/green] Processed {count} conquest stat entries")
    return "\n".join(out) + "\n\n"


def build_expedition_base_sql(p: Path, known_heroes: set[str] | None) -> str:
    data = load_json(p)
    out = ["-- hero_expedition_stats"]
    count = 0
    for row in data:
        hero_slug = row.get("hero_id")
        if not ensure_hero_known(hero_slug, known_heroes, "expedition_stats"):
            continue
        troop_type = row.get("bonus_type", "").strip().title()
        if troop_type not in {"Infantry", "Cavalry", "Archer"}:
            continue
        attack_pct = row.get("attack_pct", 0)
        defense_pct = row.get("defense_pct", 0)
        lethality_pct = row.get("lethality_pct", 0)
        health_pct = row.get("health_pct", 0)
        out.append(
            "INSERT INTO hero_expedition_stats (hero_id, troop_type, attack_pct, defense_pct, lethality_pct, health_pct)\n"
            f"VALUES ((SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)}), {sql_q(troop_type)}, {sql_q(attack_pct)}, {sql_q(defense_pct)}, {sql_q(lethality_pct)}, {sql_q(health_pct)})\n"
            "ON CONFLICT (hero_id) DO UPDATE SET\n"
            "  troop_type=EXCLUDED.troop_type,\n"
            "  attack_pct=EXCLUDED.attack_pct,\n"
            "  defense_pct=EXCLUDED.defense_pct,\n"
            "  lethality_pct=EXCLUDED.lethality_pct,\n"
            "  health_pct=EXCLUDED.health_pct;\n"
        )
        count += 1

    console.print(f"[green]‚úì[/green] Processed {count} expedition stat entries")
    return "\n".join(out) + "\n\n"


def _normalize_skill_type(s: str | None) -> str:
    if not s:
        return "Passive"
    s = s.strip().title()
    if s not in {"Active", "Passive", "Talent"}:
        return "Passive"
    return s


def build_hero_skills_sql(p: Path, known_heroes: set[str] | None) -> str:
    data = load_json(p)
    out = ["-- hero_skills + hero_skill_levels"]
    for hero in data:
        hero_slug = hero.get("hero_id")
        if not ensure_hero_known(hero_slug, known_heroes, "hero_skills"):
            continue
        for bt, skills in (
            ("Conquest", hero.get("conquest_skills") or []),
            ("Expedition", hero.get("expedition_skills") or []),
        ):
            for s in skills:
                name = s.get("name")
                if not name:
                    continue
                stype = normalize_skill_type(s.get("type"))
                desc = s.get("description")
                icon = s.get("icon_path")
                out.append(
                    "INSERT INTO hero_skills (hero_id, name, skill_type, battle_type, description, icon_path)\n"
                    f"VALUES ((SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)}), {sql_q(name)}, {sql_q(stype)}, {sql_q(bt)}, {sql_q(desc)}, {sql_q(icon)})\n"
                    "ON CONFLICT (hero_id, name, battle_type) DO UPDATE SET\n"
                    "  skill_type=EXCLUDED.skill_type,\n"
                    "  description=EXCLUDED.description,\n"
                    "  icon_path=COALESCE(EXCLUDED.icon_path, hero_skills.icon_path);\n"
                )
                for lvl, eff in sorted_level_items(s.get("levels") or {}):
                    if eff is None:
                        continue
                    out.append(
                        "INSERT INTO hero_skill_levels (skill_id, level, effects)\n"
                        f"VALUES ((SELECT id FROM hero_skills WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)}) AND name={sql_q(name)} AND battle_type={sql_q(bt)}), "
                        f"{lvl}, {as_jsonb(eff)})\n"
                        "ON CONFLICT (skill_id, level) DO UPDATE SET effects=EXCLUDED.effects;\n"
                    )

    console.print(f"[green]‚úì[/green] Processed hero skills")
    return "\n".join(out) + "\n\n"


def build_hero_talents_sql(p: Path, known_heroes: set[str] | None) -> str:
    """Build SQL for hero_talents from hero_skills.json talent data."""
    data = load_json(p)
    out = ["-- hero_talents"]
    count = 0

    for hero in data:
        hero_slug = hero.get("hero_id")
        if not ensure_hero_known(hero_slug, known_heroes, "hero_talents"):
            continue

        talent = hero.get("talent")
        if not isinstance(talent, dict):
            continue

        name = talent.get("name")
        if not name:
            continue

        description = talent.get("description")
        icon_path = talent.get("icon_path")
        max_level_effects = talent.get("max_level_effect") or talent.get(
            "max_level_effects"
        )

        out.append(
            "INSERT INTO hero_talents (hero_id, name, description, icon_path, max_level_effects)\n"
            f"VALUES ((SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)}), "
            f"{sql_q(name)}, {sql_q(description)}, {sql_q(icon_path)}, {as_jsonb(max_level_effects)})\n"
            "ON CONFLICT (hero_id) DO UPDATE SET\n"
            "  name=EXCLUDED.name,\n"
            "  description=EXCLUDED.description,\n"
            "  icon_path=COALESCE(EXCLUDED.icon_path, hero_talents.icon_path),\n"
            "  max_level_effects=EXCLUDED.max_level_effects;\n"
        )
        count += 1

    console.print(f"[green]‚úì[/green] Processed {count} talents")
    return "\n".join(out) + "\n\n"


def _extract_upgrade_value(payload: Any) -> Any:
    if not isinstance(payload, dict):
        return None
    for key in ("value_pct", "value", "value_flat", "value_amount"):
        val = payload.get(key)
        if isinstance(val, (int, float, Decimal)):
            return val
        if isinstance(val, str):
            try:
                return float(val.strip().rstrip("%"))
            except ValueError:
                continue
    return None


def _build_skill_level_sql(
    hero_slug: str, gear_level: int, combat_type: str, payload: Any, skill_exists: bool
) -> list[str]:
    if not skill_exists or not payload:
        return []
    value = _extract_upgrade_value(payload)
    if value is None:
        return []
    if combat_type == "Conquest":
        if gear_level % 2 == 0:
            return []
        skill_tier = (gear_level + 1) // 2
    else:
        if gear_level % 2 == 1:
            return []
        skill_tier = gear_level // 2
    return [
        "INSERT INTO hero_exclusive_gear_skill_levels (skill_id, gear_id, gear_level, skill_tier, upgrade_value)\n"
        f"VALUES ((SELECT id FROM hero_exclusive_gear_skills WHERE gear_id=(SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})) AND combat_type={sql_q(combat_type)}), "
        f"(SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})), "
        f"{gear_level}, {skill_tier}, {sql_q(value)})\n"
        "ON CONFLICT (skill_id, gear_level) DO UPDATE SET\n"
        "  skill_tier=EXCLUDED.skill_tier,\n"
        "  upgrade_value=EXCLUDED.upgrade_value;\n",
    ]


def build_exclusive_gear_sql(p: Path, known_heroes: set[str] | None) -> str:
    data = load_json(p)
    out = ["-- hero_exclusive_gear + levels + skills + skill_levels"]
    for g in data:
        hero_slug = g.get("hero_id")
        if not ensure_hero_known(hero_slug, known_heroes, "hero_exclusive_gear"):
            continue
        gear_name = g.get("name")
        if not gear_name:
            continue
        image_path = g.get("image_path")
        out.append(
            "INSERT INTO hero_exclusive_gear (hero_id, name, image_path)\n"
            f"VALUES ((SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)}), {sql_q(gear_name)}, {sql_q(image_path)})\n"
            "ON CONFLICT (hero_id) DO UPDATE SET\n"
            "  name=EXCLUDED.name,\n"
            "  image_path=COALESCE(EXCLUDED.image_path, hero_exclusive_gear.image_path);\n"
        )

        skill_presence = {"Conquest": False, "Expedition": False}
        cs_name = g.get("conquest_skill_name")
        cs_desc = g.get("conquest_skill_description")
        if cs_name or cs_desc:
            skill_presence["Conquest"] = True
            out.append(
                "INSERT INTO hero_exclusive_gear_skills (gear_id, battle_type, name, description)\n"
                f"VALUES ((SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})), "
                f"'Conquest', {sql_q(cs_name)}, {sql_q(cs_desc)})\n"
                "ON CONFLICT (gear_id, battle_type) DO UPDATE SET\n"
                "  name=EXCLUDED.name,\n"
                "  description=EXCLUDED.description;\n"
            )

        es_name = g.get("expedition_skill_name")
        es_desc = g.get("expedition_skill_description")
        if es_name or es_desc:
            skill_presence["Expedition"] = True
            out.append(
                "INSERT INTO hero_exclusive_gear_skills (gear_id, battle_type, name, description)\n"
                f"VALUES ((SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})), "
                f"'Expedition', {sql_q(es_name)}, {sql_q(es_desc)})\n"
                "ON CONFLICT (gear_id, battle_type) DO UPDATE SET\n"
                "  name=EXCLUDED.name,\n"
                "  description=EXCLUDED.description;\n"
            )

        for lvl, payload in sorted_level_items(g.get("levels") or {}):
            payload = payload or {}
            power = payload.get("power")
            ha = payload.get("attack")
            hd = payload.get("defense")
            hh = payload.get("health")
            leth = payload.get("lethality")
            hp_bonus = payload.get("health_bonus")
            skill1 = payload.get("skill_1")
            skill2 = payload.get("skill_2")
            out.append(
                "INSERT INTO hero_exclusive_gear_levels (gear_id, level, power, hero_attack, hero_defense, hero_health, "
                "troop_lethality_bonus, troop_health_bonus, conquest_skill_effect, expedition_skill_effect)\n"
                f"VALUES ((SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})), "
                f"{lvl}, {sql_q(power)}, {sql_q(ha)}, {sql_q(hd)}, {sql_q(hh)}, "
                f"{as_jsonb(leth) if leth else 'NULL'}, "
                f"{as_jsonb(hp_bonus) if hp_bonus else 'NULL'}, "
                f"{as_jsonb(skill1) if skill1 else 'NULL'}, "
                f"{as_jsonb(skill2) if skill2 else 'NULL'})\n"
                "ON CONFLICT (gear_id, level) DO UPDATE SET\n"
                "  power=EXCLUDED.power,\n"
                "  hero_attack=EXCLUDED.hero_attack,\n"
                "  hero_defense=EXCLUDED.hero_defense,\n"
                "  hero_health=EXCLUDED.hero_health,\n"
                "  troop_lethality_bonus=EXCLUDED.troop_lethality_bonus,\n"
                "  troop_health_bonus=EXCLUDED.troop_health_bonus,\n"
                "  conquest_skill_effect=EXCLUDED.conquest_skill_effect,\n"
                "  expedition_skill_effect=EXCLUDED.expedition_skill_effect;\n"
            )
            out.extend(
                build_skill_level_sql(
                    hero_slug, lvl, "Conquest", skill1, skill_presence["Conquest"]
                )
            )
            out.extend(
                build_skill_level_sql(
                    hero_slug, lvl, "Expedition", skill2, skill_presence["Expedition"]
                )
            )

    console.print(f"[green]‚úì[/green] Processed exclusive gear")
    return "\n".join(out) + "\n\n"


def build_skill_level_sql(
    hero_slug: str, gear_level: int, combat_type: str, payload: Any, skill_exists: bool
) -> list[str]:
    """Build SQL for gear skill level progression."""
    if not skill_exists or not payload:
        return []
    value = extract_upgrade_value(payload)
    if value is None:
        return []

    # Conquest skill upgrades on odd levels (1, 3, 5, 7, 9)
    if combat_type == "Conquest":
        if gear_level % 2 == 0:
            return []
        skill_tier = (gear_level + 1) // 2
    # Expedition skill upgrades on even levels (2, 4, 6, 8, 10)
    else:
        if gear_level % 2 == 1:
            return []
        skill_tier = gear_level // 2

    return [
        "INSERT INTO hero_exclusive_gear_skill_levels (skill_id, gear_id, gear_level, skill_tier, upgrade_value)\n"
        f"VALUES ((SELECT id FROM hero_exclusive_gear_skills WHERE gear_id=(SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})) AND battle_type={sql_q(combat_type)}), "
        f"(SELECT id FROM hero_exclusive_gear WHERE hero_id=(SELECT id FROM heroes WHERE hero_id_slug={sql_q(hero_slug)})), "
        f"{gear_level}, {skill_tier}, {sql_q(value)})\n"
        "ON CONFLICT (skill_id, gear_level) DO UPDATE SET\n"
        "  skill_tier=EXCLUDED.skill_tier,\n"
        "  upgrade_value=EXCLUDED.upgrade_value;\n",
    ]


def build_vip_levels_sql(vip_path: Path) -> str:
    """Generate SQL for VIP levels from vip_levels.json."""
    console.print("[cyan]üìñ Loading[/cyan] vip_levels.json...")

    data = load_json(vip_path)
    vip_levels = data.get("vip_levels", {})

    if not vip_levels:
        console.print("[yellow]‚ö†Ô∏è  No VIP levels found in file[/yellow]")
        return ""

    lines = [
        "\n-- ============================================================================\n",
        "-- VIP LEVELS\n",
        "-- ============================================================================\n\n",
        "INSERT INTO vip_levels (\n",
        "  level,\n",
        "  resource_production_speed_pct,\n",
        "  storehouse_capacity,\n",
        "  construction_speed_pct,\n",
        "  formations,\n",
        "  march_queue,\n",
        "  squads_attack_pct,\n",
        "  squads_defense_pct,\n",
        "  squads_health_pct,\n",
        "  squads_lethality_pct,\n",
        "  custom_avatar_upload_cooldown_hours\n",
        ") VALUES\n",
    ]

    values = []
    for level_str, stats in sorted(vip_levels.items(), key=lambda x: int(x[0])):
        level = int(level_str)
        values.append(
            f"  ({level}, "
            f"{sql_q(stats.get('resource_production_speed_pct', 0))}, "
            f"{sql_q(stats.get('storehouse_capacity', 0))}, "
            f"{sql_q(stats.get('construction_speed_pct', 0))}, "
            f"{sql_q(stats.get('formations', 0))}, "
            f"{sql_q(stats.get('march_queue', 0))}, "
            f"{sql_q(stats.get('squads_attack_pct', 0))}, "
            f"{sql_q(stats.get('squads_defense_pct', 0))}, "
            f"{sql_q(stats.get('squads_health_pct', 0))}, "
            f"{sql_q(stats.get('squads_lethality_pct', 0))}, "
            f"{sql_q(stats.get('custom_avatar_upload_cooldown_hours', 0))})"
        )

    lines.append(",\n".join(values))
    lines.append("\n")
    lines.append("ON CONFLICT (level) DO UPDATE SET\n")
    lines.append(
        "  resource_production_speed_pct=EXCLUDED.resource_production_speed_pct,\n"
    )
    lines.append("  storehouse_capacity=EXCLUDED.storehouse_capacity,\n")
    lines.append("  construction_speed_pct=EXCLUDED.construction_speed_pct,\n")
    lines.append("  formations=EXCLUDED.formations,\n")
    lines.append("  march_queue=EXCLUDED.march_queue,\n")
    lines.append("  squads_attack_pct=EXCLUDED.squads_attack_pct,\n")
    lines.append("  squads_defense_pct=EXCLUDED.squads_defense_pct,\n")
    lines.append("  squads_health_pct=EXCLUDED.squads_health_pct,\n")
    lines.append("  squads_lethality_pct=EXCLUDED.squads_lethality_pct,\n")
    lines.append(
        "  custom_avatar_upload_cooldown_hours=EXCLUDED.custom_avatar_upload_cooldown_hours,\n"
    )
    lines.append("  updated_at=NOW();\n")

    console.print(f"[green]‚úì[/green] Generated {len(values)} VIP levels")
    return "".join(lines)


def build_troops_sql(troops_path: Path) -> str:
    """Generate SQL for troops from troop-stats-normalized.json."""
    console.print("[cyan]üìñ Loading[/cyan] troop-stats-normalized.json...")

    data = load_json(troops_path)

    if not data:
        console.print("[yellow]‚ö†Ô∏è  No troop data found in file[/yellow]")
        return ""

    lines = [
        "\n-- ============================================================================\n",
        "-- TROOPS\n",
        "-- ============================================================================\n\n",
        "INSERT INTO troops (\n",
        "  troop_type,\n",
        "  troop_level,\n",
        "  true_gold_level,\n",
        "  attack,\n",
        "  defense,\n",
        "  health,\n",
        "  lethality,\n",
        "  power,\n",
        "  load,\n",
        "  speed\n",
        ") VALUES\n",
    ]

    values = []
    count = 0

    # Iterate through: infantry, cavalry, archer
    for troop_type in ["infantry", "cavalry", "archer"]:
        if troop_type not in data:
            continue

        levels = data[troop_type]

        # Iterate through troop levels (1-11)
        for level_str, tg_levels in sorted(levels.items(), key=lambda x: int(x[0])):
            level = int(level_str)

            # Iterate through True Gold levels (0-10)
            for tg_str, stats in sorted(tg_levels.items(), key=lambda x: int(x[0])):
                tg = int(tg_str)

                # Capitalize troop type to match database enum (Infantry, Cavalry, Archer)
                troop_type_enum = troop_type.capitalize()
                # Special case: ranged/archer
                if troop_type == "ranged":
                    troop_type_enum = "Archer"

                values.append(
                    f"  ({sql_q(troop_type_enum)}, "
                    f"{level}, "
                    f"{tg}, "
                    f"{sql_q(stats.get('attack', 0))}, "
                    f"{sql_q(stats.get('defense', 0))}, "
                    f"{sql_q(stats.get('health', 0))}, "
                    f"{sql_q(stats.get('lethality', 0))}, "
                    f"{sql_q(stats.get('power', 0))}, "
                    f"{sql_q(stats.get('load', 0))}, "
                    f"{sql_q(stats.get('speed', 0))})"
                )
                count += 1

    lines.append(",\n".join(values))
    lines.append("\n")
    lines.append(
        "ON CONFLICT (troop_type, troop_level, true_gold_level) DO UPDATE SET\n"
    )
    lines.append("  attack=EXCLUDED.attack,\n")
    lines.append("  defense=EXCLUDED.defense,\n")
    lines.append("  health=EXCLUDED.health,\n")
    lines.append("  lethality=EXCLUDED.lethality,\n")
    lines.append("  power=EXCLUDED.power,\n")
    lines.append("  load=EXCLUDED.load,\n")
    lines.append("  speed=EXCLUDED.speed,\n")
    lines.append("  updated_at=NOW();\n")

    console.print(f"[green]‚úì[/green] Generated {count} troop configurations")
    return "".join(lines)


def main() -> None:
    """Main seed generation orchestration."""
    console.print()
    console.print(
        Panel.fit(
            "[bold cyan]Kingshot Heroes API Seed Generator[/bold cyan]\n"
            "[dim]Generating comprehensive hero data for battle simulator[/dim]",
            border_style="cyan",
        )
    )
    console.print()

    stats = {
        "heroes": 0,
        "conquest_stats": 0,
        "expedition_stats": 0,
        "skills": 0,
        "talents": 0,
        "gear": 0,
    }

    parts: list[str] = [emit_header()]
    known_heroes: set[str] | None = None

    # Load and process heroes
    heroes_path = DATA_DIR / "heroes.json"
    if heroes_path.exists():
        console.print("[cyan]üìñ Loading[/cyan] heroes.json...")
        heroes_sql, known_heroes = build_heroes_sql(heroes_path)
        stats["heroes"] = len(known_heroes)
        parts.append(heroes_sql)
    else:
        console.print(
            "[yellow]‚ö†Ô∏è  heroes.json not found; dependent data will be skipped[/yellow]"
        )

    # Load and process conquest stats
    conquest_path = DATA_DIR / "heroes_conquest_base.json"
    if conquest_path.exists():
        console.print("[cyan]üìñ Loading[/cyan] heroes_conquest_base.json...")
        parts.append(build_conquest_base_sql(conquest_path, known_heroes))

    # Load and process expedition stats
    expedition_path = DATA_DIR / "heroes_expedition_base.json"
    if expedition_path.exists():
        console.print("[cyan]üìñ Loading[/cyan] heroes_expedition_base.json...")
        parts.append(build_expedition_base_sql(expedition_path, known_heroes))

    # Load and process skills
    skills_path = DATA_DIR / "hero_skills.json"
    if skills_path.exists():
        console.print("[cyan]üìñ Loading[/cyan] hero_skills.json...")
        parts.append(build_hero_skills_sql(skills_path, known_heroes))
        parts.append(build_hero_talents_sql(skills_path, known_heroes))

    # Load and process exclusive gear
    gear_path = DATA_DIR / "exclusive_gear.json"
    if gear_path.exists():
        console.print("[cyan]üìñ Loading[/cyan] exclusive_gear.json...")
        parts.append(build_exclusive_gear_sql(gear_path, known_heroes))

    # Load and process VIP levels
    vip_path = DATA_DIR / "vip_levels.json"
    if vip_path.exists():
        parts.append(build_vip_levels_sql(vip_path))
    else:
        console.print("[yellow]‚ö†Ô∏è  vip_levels.json not found[/yellow]")

    # Load and process troops
    troops_path = DATA_DIR / "troop-stats-normalized.json"
    if troops_path.exists():
        parts.append(build_troops_sql(troops_path))
    else:
        console.print("[yellow]‚ö†Ô∏è  troop-stats-normalized.json not found[/yellow]")

    # Write output
    parts.append(emit_footer())
    OUT_SQL.parent.mkdir(parents=True, exist_ok=True)
    OUT_SQL.write_text("".join(parts), encoding="utf-8")

    console.print()
    console.print(
        Panel.fit(
            f"[bold green]‚úÖ Successfully generated {OUT_SQL}[/bold green]\n"
            f"[dim]Ready to seed your Supabase database[/dim]",
            border_style="green",
        )
    )
    console.print()


if __name__ == "__main__":
    main()
